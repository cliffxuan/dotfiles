#!/usr/bin/env python3

"""
bao - Create human-readable archives from directories
Usage: bao [OPTIONS] DIRECTORY
"""

import argparse
import base64
import fnmatch
import os
import subprocess
import stat
import sys


def show_help():
    help_text = """
bao - Create human-readable archives from directories

USAGE:
    bao [OPTIONS] DIRECTORY

DESCRIPTION:
    Creates a human-readable archive containing all files from the specified directory.
    The archive preserves directory structure and file permissions and can be extracted
    by running it as a Python script.

OPTIONS:
    -h, --help          Show this help message
    -o, --output FILE   Output archive to FILE (default: stdout)
    -v, --verbose       Show files being archived
    -n, --name NAME     Set archive name/title
    -x, --exclude PATTERN   Exclude files matching pattern (can be used multiple times)
    --include-git-ignored   Include files that are ignored by git (default: exclude)
EXAMPLES:
    bao my_project/                     # Archive to stdout
    bao -o backup.bao my_project/       # Archive to file
    bao -v -n "My Project" src/         # Verbose with custom name
    bao -x "*.log" -x "*.tmp" src/      # Exclude log and tmp files
    bao --include-git-ignored src/      # Include git-ignored files

The generated archive is a self-extracting Python script that preserves:
    - Directory structure
    - File permissions (read/write/execute)
    - Binary and text files
"""
    print(help_text)


def is_binary_file(filepath):
    """Check if a file is binary by looking for null bytes."""
    try:
        with open(filepath, "rb") as f:
            chunk = f.read(1024)
            return b"\0" in chunk
    except (IOError, OSError):
        return False


def get_git_ignored_files(directory):
    """Get list of files ignored by git in the given directory."""
    try:
        # Check if we're in a git repository
        result = subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            cwd=directory,
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return set()

        # Get list of all files that would be ignored by git
        result = subprocess.run(
            ["git", "ls-files", "--others", "--ignored", "--exclude-standard"],
            cwd=directory,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            ignored_files = set()
            for line in result.stdout.strip().split("\n"):
                if line:  # Skip empty lines
                    ignored_files.add(line)
            return ignored_files
    except (subprocess.SubprocessError, FileNotFoundError):
        # git command not available or other error
        pass

    return set()


def should_exclude(filepath, exclude_patterns):
    """Check if file should be excluded based on patterns."""
    filename = os.path.basename(filepath)
    for pattern in exclude_patterns:
        if fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(filepath, pattern):
            return True
    return False


def get_file_mode_string(mode):
    """Convert file mode to octal string."""
    return oct(stat.S_IMODE(mode))


def create_archive(
    directory,
    output_file=None,
    verbose=False,
    archive_name="",
    exclude_patterns=None,
    include_git_ignored=False,
):
    """Create the archive."""
    if exclude_patterns is None:
        exclude_patterns = []

    directory = os.path.abspath(directory)
    directory_name = os.path.basename(directory)

    if not archive_name:
        archive_name = directory_name

    # Get git-ignored files if we should exclude them
    git_ignored_files = set()
    if not include_git_ignored:
        git_ignored_files = get_git_ignored_files(directory)
        if verbose and git_ignored_files:
            print(f"Found {len(git_ignored_files)} git-ignored files", file=sys.stderr)

    # Collect all files
    files_to_archive = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            filepath = os.path.join(root, file)
            relative_path = os.path.relpath(filepath, directory)

            if should_exclude(relative_path, exclude_patterns):
                if verbose:
                    print(f"Excluding: {relative_path}", file=sys.stderr)
                continue

            # Check if file is git-ignored
            if not include_git_ignored and relative_path in git_ignored_files:
                if verbose:
                    print(f"Excluding (git-ignored): {relative_path}", file=sys.stderr)
                continue

            files_to_archive.append((filepath, relative_path))
            if verbose:
                print(f"Adding: {relative_path}", file=sys.stderr)

    # Generate the archive content
    archive_lines = [
        "#!/usr/bin/env python3",
        '"""',
        f"Self-extracting archive: {archive_name}",
        f"Generated by bao from: {directory_name}",
        '"""',
        "",
        "import os",
        "import sys",
        "import base64",
        "import stat",
        "",
        "def extract_archive():",
        '    """Extract the archive contents."""',
        "    files = [",
    ]

    # Add file data
    for filepath, relative_path in files_to_archive:
        file_stat = os.stat(filepath)
        file_mode = get_file_mode_string(file_stat.st_mode)

        if is_binary_file(filepath):
            with open(filepath, "rb") as f:
                content = base64.b64encode(f.read()).decode("ascii")
            archive_lines.append(
                f'        ("{relative_path}", "{file_mode}", "binary", "{content}"),'
            )
        else:
            try:
                with open(filepath, "r", encoding="utf-8") as f:
                    content = f.read()
                # Escape quotes and backslashes
                content = (
                    content.replace("\\", "\\\\")
                    .replace('"', '\\"')
                    .replace("\n", "\\n")
                )
                archive_lines.append(
                    f'        ("{relative_path}", "{file_mode}", "text", "{content}"),'
                )
            except UnicodeDecodeError:
                # Treat as binary if we can't decode as UTF-8
                with open(filepath, "rb") as f:
                    content = base64.b64encode(f.read()).decode("ascii")
                archive_lines.append(
                    f'        ("{relative_path}", "{file_mode}", "binary", "{content}"),'
                )

    archive_lines.extend(
        [
            "    ]",
            "",
            f"    # Create base directory: {directory_name}",
            f"    base_dir = '{directory_name}'",
            "    os.makedirs(base_dir, exist_ok=True)",
            "",
            "    for relative_path, file_mode, content_type, content in files:",
            "        # Full path includes base directory",
            "        full_path = os.path.join(base_dir, relative_path)",
            "        ",
            "        # Create directory if needed",
            "        dir_path = os.path.dirname(full_path)",
            "        if dir_path:",
            "            os.makedirs(dir_path, exist_ok=True)",
            "",
            "        # Write file content",
            "        if content_type == 'binary':",
            "            with open(full_path, 'wb') as f:",
            "                f.write(base64.b64decode(content))",
            "        else:",
            "            with open(full_path, 'w', encoding='utf-8') as f:",
            "                f.write(content)",
            "",
            "        # Set file permissions",
            "        os.chmod(full_path, int(file_mode, 8))",
            "",
            "if __name__ == '__main__':",
            "    extract_archive()",
            f"    print('Extracted archive: {archive_name}')",
        ]
    )

    archive_content = "\n".join(archive_lines)

    # Output the archive
    if output_file:
        with open(output_file, "w") as f:
            f.write(archive_content)
        # Make the output file executable
        os.chmod(output_file, 0o755)
        if verbose:
            print(f"Archive created: {output_file}", file=sys.stderr)
    else:
        print(archive_content)


def main():
    parser = argparse.ArgumentParser(
        description="Create human-readable archives from directories"
    )
    parser.add_argument("directory", help="Directory to archive")
    parser.add_argument(
        "-o", "--output", help="Output archive to FILE (default: stdout)"
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Show files being archived"
    )
    parser.add_argument("-n", "--name", help="Set archive name/title")
    parser.add_argument(
        "-x",
        "--exclude",
        action="append",
        default=[],
        help="Exclude files matching pattern",
    )
    parser.add_argument(
        "--include-git-ignored",
        action="store_true",
        help="Include files that are ignored by git (default: exclude)",
    )

    args = parser.parse_args()

    # Check if directory exists
    if not os.path.isdir(args.directory):
        print(f"Error: Directory '{args.directory}' does not exist.", file=sys.stderr)
        sys.exit(1)

    create_archive(
        directory=args.directory,
        output_file=args.output,
        verbose=args.verbose,
        archive_name=args.name or "",
        exclude_patterns=args.exclude,
        include_git_ignored=args.include_git_ignored,
    )


if __name__ == "__main__":
    main()
